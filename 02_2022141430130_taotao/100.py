# -*- coding: utf-8 -*-
"""Untitled1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1mhpKxQQ7rLpseP8CDyZUSTpCPJ8kVBIw
"""



import numpy as np
from collections import Counter

def simulate_one_trial(N, K, strategy='random'):
    """
    模拟一次囚犯抽签实验
    :param N: 囚犯和盒子的数量（总数）
    :param K: 每个囚犯最多打开的盒子次数
    :param strategy: 策略选择，'random' 表示随机选择盒子，'loop' 表示循环链查找策略
    :return: (bool, int or None)
             bool表示本次实验是否全员找到自己的编号，
             当strategy为'loop'时返回最大循环长度，否则返回None
    """
    # 随机生成1~N的盒子编号排列，表示盒子里标签的分布
    boxes = np.random.permutation(N) + 1  # np.random.permutation返回0~N-1，+1变成1~N

    if strategy == 'random':
        # 随机策略：每个囚犯随机选择K个不同盒子查看
        for prisoner in range(1, N+1):
            opened = np.random.choice(N, K, replace=False)  # 随机选K个盒子索引（0-based）
            # 判断囚犯编号是否在打开的盒子里的标签中
            if prisoner not in boxes[opened]:
                return False, None  # 有人没找到，失败
        return True, None  # 全员找到，成功

    elif strategy == 'loop':
        max_cycle_length = 0  # 记录所有囚犯尝试中遇到的最大循环长度
        # 循环策略：根据盒子编号形成的排列，找自己的循环链
        for prisoner in range(1, N+1):
            current_box = prisoner  # 从自己编号对应的盒子开始查找
            for step in range(K):
                label = boxes[current_box - 1]  # 打开盒子，读取标签
                if label == prisoner:
                    # 找到了自己的编号，更新最大循环长度
                    max_cycle_length = max(max_cycle_length, step + 1)
                    break  # 找到后停止继续查找
                else:
                    # 没找到，跳转到标签所指向的盒子编号，继续查找
                    current_box = label
            else:
                # 超过K次未找到，直接返回失败和当前最大循环长度
                return False, max_cycle_length
        # 所有人都找到，返回成功和最大循环长度
        return True, max_cycle_length

def simulate_once(N=100, K=50, T=10000):
    results_random = []
    results_loop = []
    loop_cycle_lengths = []

    for _ in range(T):
        success_random, _ = simulate_one_trial(N, K, strategy='random')
        results_random.append(success_random)

        success_loop, max_cycle_len = simulate_one_trial(N, K, strategy='loop')
        results_loop.append(success_loop)
        if max_cycle_len is not None:
            loop_cycle_lengths.append(max_cycle_len)

    success_rate_random = sum(results_random) / T
    success_rate_loop = sum(results_loop) / T

    return success_rate_random, success_rate_loop, loop_cycle_lengths

def simulate(N=100, K=50, T=10000, repeats=5):
    random_rates = []
    loop_rates = []
    all_cycle_lengths = []

    for i in range(repeats):
        sr, sl, cycle_lengths = simulate_once(N, K, T)
        random_rates.append(sr)
        loop_rates.append(sl)
        all_cycle_lengths.extend(cycle_lengths)
        print(f"第{i+1}次模拟：随机策略成功率={sr:.4f}, 循环策略成功率={sl:.4f}")

    avg_random = sum(random_rates) / repeats
    avg_loop = sum(loop_rates) / repeats

    print(f"\n5次模拟平均结果：")
    print(f"随机策略平均成功率: {avg_random:.4f}")
    print(f"循环策略平均成功率: {avg_loop:.4f}")
    return avg_random, avg_loop, all_cycle_lengths

if __name__ == "__main__":
    simulate()